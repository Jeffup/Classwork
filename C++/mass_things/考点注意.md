## Attention！
1. 在c++语言中，类和结构体有本质区别，类中包含数据及操作函数，而结构体只包含有数据。
2. C语言本身没有输入输出语句
3. 对于十六进制：0x12这里是零和小写字母x
  1 2 3 4 5 6 7 8 9 a b c d e f (f==15)
4. ？不可作为分隔符
5. C++允许使用友元，但是友元会破坏封装性。√
6. C++中为了减轻使用者的负担，与C语言相比较C++中减少了一些运算符。×
7. 在编写C++程序时，一定要注意采用人们习惯使用的书写格式，否则将会降低其可读性√ 
8. C++是一种以编译方式实现的高级语言。√
9. 预处理过程、编译过程和连接过程
10. main()的位置可以任意
11. 结构化程序设计3种基本结构：顺序，选择，循环
12. sizeof和strlen:sizeof()是计算整个式子（包括隐藏的eg.\0），而strlen只是计算显示的（如果\0在外面，只计算前面的）；
> * short things[]={1,2,3};
> * sizeof(things)==2*3==6;  things即是things[0]的地址，也是整个数组的长度
> * sizeof(*things)==short==2;  *things是short，而things是指向short的指针
> * sizeof(&thing)==指针==4;   对things这个指针取地址，就是指该指针的本身
strcmp（str1,str2）:用于比较str1,str2两字符数组或者字符串常量，元素是否相同，如果相同则return 0；也可用”????”来代替str1/2。
他接受字符串地址（指针，数组名，字符串常量）。
strcat(str1,str2):将str2接到str1后面
strcpy(str1,str2)：把str1中的值赋给str2

13. 结构化程序设计基本思想：算法+数据结构；对象+对象+……+算法=程序
   基本单位：函数
14. 编辑（标准C++扩展名）：.cpp | 编译（目标程序扩展名）.obj | 链接（可执行文件）.exe
15. C语言不是面向对象的程序设计语言
16. 只要是整形（类整形也是）都可以用unsigned来修饰：char int long 
17. 科学计数法：e的前面必须要有数字（即使是1），它的后面不能是小数
18. 双目运算符<单目运算符（优先级）
19. 注意二进制的算法
20. 返回值与形参
>* 值、指针传递要为形参分配内存空间   而引用类型不需要（因为共用）
>* 指针返回时，函数会为它先准备一个指针（分配内存空间），将地址保存在那个临时指针除，然后调用析构函数。而引用传递时，就不需要，而且它还可以作为左或右值！
>* 默认值（缺省）：从右到左设置！一般在原型就写上，而在定义的时候就不需要了（二义性）
>* 返回值的误差：有时候如果返回值为0；那么储存的时候可能会是很小的数：1E-6

应用：if( f(x) == 0)可能会出错，f(x)返回的可能不是0，这个条件可能不成立！
解决：const double zero = 1E-6; if( abs( f(x) ) <zero);
21. 行指针，顾名思义就是指向一行的指针。那么哪里会用到行指针呢，用的最多的，那就是二维指针了，大家都知道，我们通常把二维指针看成一个行列式，但是它在内存中的排序却是和一维指针一样的。
> 比如组a[2][3]={{1，2，3}{4，5，6}}，a是整个数组的首地址，同时也指向第一行元素，即a是一个行指针，它每加1，所指地址移动二维数组的一行，a+1指向第二行元素。

22. 用户标识符：由英文字母，下划线，数字组成，开头只能是字母或者下划线
23. 使用new运算符进行数组的动态分配时，new需要确定分配的数组的大小（可以是变量也可以是常量）；
24. 静态变量：（可见性和存在性都不一致），分配内存后将在整个程序结束后才释放。
25. 类与对象有什么区别？ 
 答：类是类型，是对象的抽象，对象是类的具体实例。一个类可以有多个对象，每个对象都有自己的存储单元，而类不占存储单元。
函数重载与函数覆盖有什么不同，它们与多态有什么关系？ 
 解答要点：  函数重载是指函数名相同，而函数的参数个数或类型不同；覆盖是指在派生类中成员函数与基类成员函数的函数名、参数个数、类型与返回值均相同；C++中正是通过虚函数的覆盖，实现多态的功能。
26. 连续比较：eg:a<=b<=c;这里先进行（a<=b?）它的返回值为1/0所以第二个步骤是1/0与c比较
27. 位或、位与的运算符优先等级是很低的，eg.3*6|3<<1
这里先进行3*6==18然后计算18的二进制数10010，然后进行3<<1(3的二进制数“11”)
11左移一位变成110，然后和10010进行位或运算（|是遇到1则为1，&是遇到0为0，^是遇到相同的为1）
28. 在16位机中int的字节为2（普通为4）
29. 单目、赋值、三目运算符的结合顺序都是从右到左。

30. 二义性：一般指多重进行同一操作，或者该句子有歧义：(a = 31. -a++  [a本来的值为5]
究竟a++是用哪一个值？

31. 关于指针赋值问题：

```
  	char a[4] = {'a','b','c'};
	char* pch;
	pch = a;
	int num = 0;
	int* pnum = &num;
	*pnum = num + 1;【num会改变】
```

32.字符常量：eg.’y’、’*’，还有转义字符：’\n’。 ASCII
任何字符常量与一个任意大小的整型数进行加减都是有意义的。×
* 转义序列表示法只能表示字符不能表示数字，转义序列表示法只能表示字符不能表示数字。

33.关于enum：
```
#include "stdafx.h"
#include<iostream>
#include<string>
using namespace std;
enum city{beijing ,shanghai = 2};
int main()
{
	city c;
	c = beijing;//不能进行cin>>c,只能进行赋值，而且还应该是city上的值。
	cout << c << '\t' << shanghai << endl;
    return 0;
}
```
34. 左移和右移（位移运算符）：这要看操作的是什么数字，如果有有符号的，左边以符号位（即最高为）补齐，否则以0补齐（一般来说如果是负号就补上1，否则就是0）

```
int main()
{
	int a = -3;//如果是3的话就输出1，-3的话就输出-2
	cout << (a >> 1) << endl;
    return 0;
}
```

∴移位运算符在移位操作中，无论左移还是右移，所移出的空位一律补0；✖

32. 高地址和低地址：
字节顺序是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序。
小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处；
大端字节序是高字节数据存放在低地址处，低字节数据存放在高地址处。
高、低字节
一般PC是低字节序，如果按平时书写习惯，从左到右是高位到地位的顺序，则例如0X12345678，在内存中的情况是
高地址 
12 
34 
56 
78 
低地址、高地址：内存地址可以对应十六进制的数值，值大的为高地址，否则为低地址；
>总结： 
> 整数类型内部：低地址存储低位，高地址存储高位。 
> 局部变量：先定义的高地址，后定义的低地址。 
> 类，结构体，数组：先定义的低地址，后定义的高地址。 
> 数组实际占用的空间，要比元素大，感觉上像是给数组名本身一个“指针类型”的空间，即4个字节。

拓展：Intel用小端，而TCP/IP用大端

33. 下面程序输出是多少？

```
Union U { 
char str[2]; 
short int num; 
}; 
int main() { 
  U u; 
  u.str[0] = 10; 
  u.str[1] = 1; 
  cout << u.num << endl; 
  system("PAUSE"); 
return 0; 
}
```
> 结果为266。对于整数类型，都是低字节存低位，高字节存高位，因此低位是10，高位是1，结果=1*256+10=266。

34. 下面不同变量之间地址大小关系

35. 
```
class Test { 
public: 
int m; 
int n; 
}; 
int main() { 
int a; 
char b; 
int c[10]; 
  Test t; 
  cout << (size_t)&a << endl; 
  cout << (size_t)&b << endl; 
  cout << (size_t)&c << endl; 
  cout << (size_t)&t << endl; 
  cout << (size_t)&t.m << endl; 
  cout << (size_t)&t.n << endl; 
  system("PAUSE"); 
return 0; 
}
```

> (size_t)&a > (size_t)&b > (size_t)&c > (size_t)&t.n > (size_t)&t.m = (size_t)t 
> 2293612   > 2293611  >  2293552  >  2293548     > 2293544      = 2293544 

a、b、c、t都是局部变量，在栈上存储，栈是从高地址到低地址，因此地址逐渐减小。结构体内部，先定义的地址小，后定义的地址大，这与类内的成员，数组总的元素，都是类似的。 
此外，值得注意的是(size_t)&a-(size_t)&b=1，刚好是1个字节，即b的大小。(size_t)& b-(size_t)&c=59，这是因为首先需要字节对齐，补3个字节，从2293611，补到2293608，从2293607到 2293552剩下的44个字节是数组占用，注意数组只有10个元素是40个字节，还有4个字节应该是数组名占用的，把数组名看作一个指针？或者是数组名本身包含数组长度的信息，具体情况不是很清楚，不过int a[10]占用的空间是44个字节，而10个int类型的变量占用40个字节。t的字节分配很简单，没有什么了。 

总的来说，具体的地址，需要考虑“栈的高地址到低地址”和“字节对齐”以及“数组”这样的特殊情况等等。

36. 
```
int main() 
{double a = .35;/*会自动补0*/  cout << a;return 0;}
```

37.类型定义：typedef
38.有关八进制、十六进制的输入输出：
因为八进制是三位数（前面是0也要写，只有当第一位等于0时写上去，才可被转化为八进制，否则会直接被转化为十进制数），而十六进制是0x??，所以和其他数字不一样。

```
int main() 
{
	unsigned int x = 015, y = 0x2b, z = 15;
	cout << x << '\t' << y << '\t' << z << endl;
}
```
> 13      43      15请按任意键继续. . .

39.带参数的宏定义：#define 宏名（参数表） 字符串，（相当于内联函数）他有很多弊端！而且引用的实参只能是常量！eg.area(2,by)；by是变量的话是不行的。
除了一般的字符串替换，还要做参数代换
格式：
> #define 宏名（参数表） 字符串

例如：	#define S(a,b) a*b
area=S(3,2)；第一步被换为area=a*b; ，第二步被换为area=3*2;
类似于函数调用，有一个哑实结合的过程：
（1）实参如果是表达式容易出问题
	#define S(r) r*r
area=S(a+b);第一步换为area=r*r;,第二步被换为area=a+b*a+b;
正确的宏定义是#define S(r) (r)*(r)
（2）宏名和参数的括号间不能有空格
（3）宏替换只作替换，不做计算，不做表达式求解
（4）函数调用在编译后程序运行时进行，并且分配内存。宏替换在编译前进行，不分配内存
（5）宏的哑实结合不存在类型，也没有类型转换。
（6）函数只有一个返回值，利用宏则可以设法得到多个值
（7）宏展开使源程序变长，函数调用不会
（8）宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）
40. break只能在循环和开关中使用；default可以放在开关中的任何位置！switch不会陷入死循环！Break语句可以出现在各种循环体中。continue语句只能出现在循环体中。

41. 公约数为1、2、3、6

```
#include "stdafx.h"
#include<iostream>
using namespace std;
void gong(int num1, int num2);
int main() 
{
	int num1, num2;
	cout << "请输入两个数：" << endl;
	cin >> num1 >> num2;
	gong(num1, num2);
	return 0;
}
void gong(int num1, int num2)
{
	int k(1);
	cout << num1 << "和" << num2 << "的公约数是：";
	while (k != ((num1 < num2) ? num1 : num2))
	{
		if ((num1%k == 0) && (num2%k == 0))
		{
			cout << k << ',';
		}
		++k;
	}
	cout << endl;
}
```

> 请 输 入 两 个 数 ：
> 18 30
> 18和 30的 公 约 数 是 ： 1,2,3,6,
> 请按任意键继续. . .

42. 指针的赋予地址：
①int *pi = &arr;
②int *pi; pi = (int *) &arr;其实可以删去(int *)
多维数组的指针表示：
①int a[4][3],(*p)[3] = a;(p指向a[0])
②float a[2][4][3],(*p)[4][3] (a);( p指向a[0])
③int a[2][4][3],(*p)[3] = a[0][0]; ( p指向a[0][0])
43. 所有的函数在定义它的程序中都是可见的。×


资料：
https://wenku.baidu.com/view/d8e8361ba2161479171128da.html
https://wenku.baidu.com/view/2b82ef07fc4ffe473268ab04.html
http://www.docin.com/p-697712833.html
