		      				**算法设计与分析考点**
- - - -
# 算法的定义
* 算法是解决问题的方法或过程。严格来说是满足下述性质的指令序列。
1. 输入
2. 输出
3. 确定性
4. 有限性
- - - -
# 算法复杂性的定义
> 算法复杂性的高低体现运行该算法所需要的计算机资源的多少 
 
- - - -
# RAM模型[（random access machine）](https://yq.aliyun.com/articles/174816)
* 计算模型（model of computation），**它是抽象的算法设计与分析的基础**。计算模型可以执行数学运算、逻辑运算、存储器访问等基本操作。它仅存在于我们的思维之中，但是它包含了计算设备进行计算的核心运作机理。
* RAM模型也是一种计算模型，包含输入和输出。RAM模型执行的**程序不是存放在存储器内的**，因而程序_不能修改其自身_。
* 有两种基本寻址方式：直接，间接
- - - -
# 五个渐进符号的意义

# P问题与NP问题
### P类问题：
存在多项式时间算法的问题。
### NP类问题：
能在多项式时间内验证得出一个正确解的问题。(NP:Nondeterministic polynominal，非确定性多项式)
> 所以这就引出了这类讨论的一个千年问题：是否 NP类问题=P类问题？  
* 即，是否所有能在多项式时间内验证得出正确解的问题，都是具有多项式时间算法的问题呢？有的可以，有的不行。
* NPC类问题（Nondeterminism Polynomial complete）：存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件： 

首先，它得是一个NP问题；

然后，所有的NP问题都可以约化到它。
* 要证明npc问题的思路就是： 
先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它。

- - - -
# [递推式求解](https://blog.csdn.net/u013340360/article/details/81030820)
## 归纳法（万不得已不用）
## 替换法
* 不断用递推方程的右部替换左部，例如：

* 可以使用**换元**方法来解决比较难迭代的式子，常用的有如n=2^k等。
## 差消法
* 这个就是得到一条式子如**t(n)/n=t(n-1) /（n-1）-k**，那么就可以形成差消法了。
## 递归树法
* 建立递归树，每次迭代将函数项作为儿子，非函数项作为根的值
* 其实就跟替换法差不多嘛！
## 主方法（这个常用）
* 必须长成那个模样！
![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/20180713165414641.png)
![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/20180713170157671.png)
## 特征方程
* 使用特征根解法需要**判断**递推方程是**线性**还是**非线性**，写出特征方程，对特征方程进行求解，**根据特征方程的解**是两个不同的实根、两个相等的实根、虚根等写出**通解**，最终得出递推方程的解。
* 下面举一个**非齐次线性递推**关系两个不同实根的例子。
![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/20180713173214167.png)：递归关系
解：
1. 首先确定这是一个非齐次递推关系式，先写出对应齐次递推关系式的特征方程为：
![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/20180713173317573.png)
2. 求出特征根为 x1 = 3, x2 = 4 为两个不等实根。对应的齐次递推关系的通解为
 ![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/20180713173424915.png)
3. 由于原递推关系为非齐次，于是设特解为：![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/20180713173512182.png)，
4. 将其带入非齐次递推关系的通解中，求出A和B。可以得到A=2，B=1。所以对应非齐次递推关系的通解为：
![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/20180713173649545.png) 
5. 最后将初始条件带入该通解，可以求出![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/20180713173719994.png)。所以通解为![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/20180713173742615.png)
- - - -
# 常用算法（算法步骤、需满足的基本要求、一般复杂性分析方法）
## 分治法
### 算法步骤
1. 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
2. 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
3. 合并：将各个子问题的解合并为原问题的解。

### 需满足的基本要求
1. 该问题的规模缩小到一定的程度就可以容易地解决
2. 该问题可以分解为若干个规模较小的相同问题，即该问题具有**最优子结构性质。**
3. 利用该问题分解出的子问题的解**可以合并**为该问题的解；
4. 该问题所分解出的各个**子问题是相互独立**的，即子问题之间不包含公共的子子问题。

### 一般复杂性分析方法
一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：
**T（n）= k T(n/m)+f(n)**
通过迭代法求得方程的解：
递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当mi≤n<mi+1时，T(mi)≤T(n)<T(mi+1)。

## 动态规划
### 算法步骤
1. **划分阶段**：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的 _阶段一定要是有序的或者是可排序的_ ，否则问题就无法求解。
2. **确定状态和状态变量**：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，**状态的选择要满足无后效性。**
3. **确定决策并写出状态转移方程**：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
4. **寻找边界条件**：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

### 需满足的基本要求
1. **最优化原理**：如果问题的最优解所包含的**子问题的解也是最优的**，就称该问题具有最优子结构，即满足最优化原理。
2. **无后效性**：即某阶段状态**一旦确定**，就 _不受这个状态以后决策的影响_ 。也就是说，某状态以后的过程不会影响以前的状态，**只与当前状态有关**。
3. **有重叠子问题**：即**子问题之间是不独立**的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

### 一般复杂性分析方法

## 贪心算法
### 算法步骤
1. 建立数学模型来描述问题。
2. 把求解的问题分成若干个子问题。
3. 对每一子问题求解，得到子问题的局部最优解。
4. 把子问题的解局部最优解合成原来解问题的一个解。

### 需满足的基本要求
1.  **无后效性**：即某阶段状态**一旦确定**，就 _不受这个状态以后决策的影响_ 。也就是说，某状态以后的过程不会影响以前的状态，**只与当前状态有关**。
2. **最优子结构**
3. 贪心选择性

### 一般复杂性分析方法

## 对比分治法/动态规划法
* **共同点**：二者都要求原问题**具有最优子结构性质**,都是将原问题分而治之,分解成若干个规模较小(小到很容易解决的程序)的子问题.然后将子问题的解合并,形成原问题的解.
* **不同点**：分治法将分解后的子问题看成相互独立的，通过用递归来做。
动态规划将分解后的子问题理解为相互间有联系,有重叠部分，需要记忆，通常用迭代来做。

## 对比贪心法/动态规划法
### 联系
1. 都是一种推导算法
2. 都是分解成子问题来求解，都需要**具有最优子结构**
### 区别
1. 贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；
动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解
2. 贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可（通常这个“最优”都是基于当前情况下显而易见的“最优”）；这样的话，就不需要知道一个节点的所有子树情况，于是构不成一棵完整的树；即**自上而下**
动态规划：动态规划则**自底向上**，从叶子向根，构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，最后得到一棵完整的树，并且最终选择其中的最优值作为自身的值，得到答案
3. 根据以上两条可以知道，贪心不能保证求得的最后解是最佳的，一般复杂度低；而动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。
4. 针对0-1背包问题：这个问题应**比较**选择该物品和不选择该物品**所导致的最终方案**，然后再作出最好选择，由此就导出许多互相重叠的子问题，所以用动态规划。

- - - -
# 贪心选择性含义
* 所求问题的整体最优解可以通过一系列局部最优的选择来得到。可以参考0 1背包问题

# 最优子结构含义
* 当问题的最优解包含了其子问题的最优解时，则称该问题具有最优子结构性质。这个性质是动态规划算法求解的重要线索。
- - - -
# 经典排序算法及其复杂度、稳定性
![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/%E7%85%A7%E7%89%87%202019%E5%B9%B410%E6%9C%8821%E6%97%A5%20190653.jpg)
- - - -
# 回溯法/分支限界法的基本思想/算法步骤/必须满足的基本要素/一般复杂性分析方法; 
## 回溯法
### 算法步骤
1. 针对所给问题，定义问题的解空间；
2. 确定易于搜索的解空间结构；
3. 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。
### 伪代码
* **子集树**
```
void backtrack(int t)
{
    if(t > n) output(x);
    else
        for(int i = 0; i <= 1; i++) 
        {
            x[t] = i;//这里i是0或者1，就是取还是不取的问题
            if(constraint(t) && bound(t)) backtrack(t+1);
        }
}
注：t表示递归深度，表示树的第t层。当t > n时，算法已搜索到叶结点，由output( x ) 输出可行解。否则，记录当前选择的x的值（即0或1），并递归遍历所有子树（这里只有左右子树）。(constraint(t) && bound(t)) 表示剪枝函数，只有满足剪枝函数的子树才继续递归。一棵子集树一共有2**n个可搜索的解，对于所有可用子集树表示解空间的问题都是在这
```![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/041055098941015.png)
这里n为3（3层）
* **排序树**
```
void backtrack(int t)
{
    if(t > n) output(x);
    else
        for(int i = t; i <= n; i++)  //与子集树不同，搜索剩下的结点
        {
            swap(x[t], x[i]);//通过交换来达到所有可能序列的遍历尝试
            if(constraint(t)&&bound(t)) backtrack(t+1);//交换还是不交换
            swap(x[t], x[i]);
        }
}
``` ![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/041055117078601.png)

### 必须满足的基本要素


### 一般复杂性分析
> 对于问题的解空间结构通常以树或图的形式表示，常用的两类典型的解空间树是**子集树**和**排列树**。当所给的问题是从n个元素的集合S中找到S满足某种性质的子集时，相应的解空间树称为子集树。  
例如，n个物品的0-1背包问题所对应的解空间树是一棵子集树
* 这类**子集树**通常有**2^n个叶结点**，遍历子集树的算法需要**O(2^n)**计算时间。
* 当所给问题是确定**n个元素满足某种性质的排列时**，相应的解空间树称为**排列树**。排列树通常有**n！个叶结点**。因此，排列树需要**O(n!)**计算时间。
- [ ] 也就是说，有多少个节点就是多少时间复杂度？

## 分支限界法
**常见的两种分支限界法：**
（1）队列式(FIFO)分支限界法
按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。 
（2）优先队列式分支限界法
按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。
### 算法步骤
1. 按宽度优先策略遍历解空间树
2. 在遍历过程中，对处理的每个结点i，根据界限函数，估计沿该结点向下搜索所可能达到的完全解的目标函数的可能取值范围—界限bound(i)=[dow(i), up(i)]
3. 从中选择使目标函数取的极小值的结点优先进行宽度优先搜索，从而不断调整搜索方向，尽快找到问题的解。
### 必须满足的基本要素
### 一般复杂性分析
### 关键问题：
* **采用分枝限界法求解的3个关键问题如下：**
1. 如何确定合适的限界函数。
2. 如何组织待处理结点的活结点表。
3. 如何确定解向量的各个分量
# 剪枝函数的作用;
用约束函数在扩展结点处剪去不满足约束的子树；和用限界函数剪去得不到最优解的子树。这两类函数统称为剪枝函数。
采用剪枝函数，**可避免无效搜索，提高回溯法的搜索效率**。 
在分支限界法中使用剪枝函数，可以加速搜索。该函数给出每一个可行结点相应的子树可能获得的最大价值的上界。如果这个上界不比当前最优值更大，则说明相应的子树中不含问题的最优解，因而可以剪去。
另一方面，也可以将上界函数确定的每个结点的上界值作为优先级，以该优先级的非增序抽取当前扩展结点。这种策略有时可以更迅速地找到最优解。

# 对比回溯法/分支限界法
## 求解目标：
> **回溯法**的求解目标是找出解空间树中满足约束条件的**所有解**；  
> **分支限界法**的求解目标则是找出**满足约束条件的一个解**，或是在满足约束条件的解中找出在某种意义下的最优解。   
## 搜索方式的不同：
回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。
- [ ] 或者这样表述：
* 回溯法
> **深度优先搜索**堆栈活结点的**所有可行子结点被遍历后**才被从栈中弹出找出满足约束条件的所有解  
* 分支限界法
> **广度优先或最小消耗优先搜索队列**、优先队列每个结点**只有一次成为活结点的机会**找出满足约束条件的一个解或特定意义下的最优解  
# 分支限界法中活结点存储的数据结构
- - - -
# 三大类算法包括哪些？（确定性、概率、近似）
## 确定算法(常规方法、分治法、动态规划、贪心、回溯、分支限界等)
## 概率算法(舍伍德算法、拉斯维加斯算法、蒙特卡罗算法)的定义和典型例子
1. 数字算法
利用随机性求数字问题的近似解，概率算法获得的答案是近似的，通常执行时间越长，精度就越高，误差就越小。
举例：Pi值的估计；数字积分（计算定积分的值）；概率计数（求集合X的势）
2. Sherwood算法
**总是给出正确的答案**。**减少消除好的和坏的实例之间的差别**，即平滑不同输入实例的执行时间。比起确定性算法A，概率算法B为取得均匀性增加了时间成本S(n)，所以平均的执行时间略微增加。这是为了得到一个很好的平均性能。
举例：选择和排序（划分元的选取）；随机预处理；搜索有序表；跳跃表；线性时间选择算法；
3. Las Vegas算法
比起Sherwood，Las Vegas算法一般能获得更有效率的算法，但是要**冒着找不到解的风险，要么返回正确的解**，要么随机决策导致一个僵局。
和Monte Carlo算法相同，成功的概率随着执行时间的增加而增加。
举例：8皇后问题；模p平方根；整数的因数分解
4. Monte Carlo算法
**可能会返回错误的答案**，对任何实例均以高概率找到正确解。随着重复次数的增加，正确概率增加。算法的时间表示为实例大小和可接受错误概率的函数。
有偏算法：偏真算法(true-biased)、偏y0算法
举例：主元素问题；素数测定；矩阵乘法验证
## 近似算法(数值计算)
- - - -
# 简答类
- - - -
# 找零（贪心算法的分析过程）
- - - -
# 矩阵乘法最优（动态规划）
- - - -
# 空间树求解加法（回溯法）
- - - -
# 设计分析类例题 典型算法:
## 线性时间选择(分治)
### 第一种方法：快速排序式划分（用randomizedPartition函数）
用随机化算法选择基准设为i，将数组分为两部分，看两遍的个数，如果你要查的k大于第一段的数的个数，则在第二段找第k-i大的数。
**而另外一边就不处理了**
所以平均复杂度为O(n) 
### 第二种方法
即用BFPRT算法找划分基准，这样划分的大小必定在1/4到3/4之间。时间复杂度为：
![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/%E7%85%A7%E7%89%87%202019%E5%B9%B410%E6%9C%8822%E6%97%A5%20182250.jpg)

## 最接近点对(分治)：
* 在一维的时候，只要排好序就可以完成搜索，时间复杂度为O(nlogn)。但是扩充到二维的话，就不那么好做了。
继续说一维，虽然用排序就可以了做出来，但是如果用递归来做的话，就需要有合并来合并分开的子问题。但是合并会产生新的问题：如果最短距离的那两个点在两边，怎么办？
若两部分的最小距离为d，中心为m，如果在m-d:m && m:m+d之间有点（各有一个），就可以说明还存在更小的点！按照这个思维拓展二维：
* 二维：二维的话，画个矩形不就得了？两个矩形里面如果各包含一个点，那么就说明可能存在更短的距离。由于矩阵的稀疏性，故不存在多于六个点在同一个d*2d大小的矩阵里面。因为要大于d啊
![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/%E7%85%A7%E7%89%87%202019%E5%B9%B410%E6%9C%8822%E6%97%A5%20185417.jpg)
即：一方的点只要寻找最多6个点即可得到。那么是哪六个点呢？**投射到一维坐标不就得了！**只要距离该点的距离小于d就ok。

## 最大子段和(分治，动态规划)：
### 分治法：
自然是分左右和中了。至于结束的函数，自然是只有分的只有一个元素的时候了。这个是结构。
好，现在来合并子问题：首先，现在通过递归，左右的最大子串已经出来了，现在求中间的最大子串，各自都从中间进行，往左右扩散开来，就其最大值，然后两边相加，得到中间的最大值。
比较这三个哪个大，返回哪个，ok！例子：
-1 1 3 5 7    -4 -2 -9 -8 6            arr值
分
-1 1 3 5 7    -4 -2 -9 -8 6            arr值
再分
-1 1 3     5 7    -4 -2 -9      -8 6            arr值
再分
-1 1      3     5      7    -4 -2      -9      -8      6            arr值
能分就分，不能分就返回
-1     1     r3   r5    r7    -4     -2      r0     r0      r6            arr值
回溯开始
r0     r1     r3   r5    r7    r0     r0      r0     r0      r6            arr值
。。。计算中间值。。有点麻烦，不写了

### 动态规划：
我感觉这个方法很。。。
不多说，来方法：一个for循环，一直加，当单独遇到小于0的，就赋予0，其他，照样加。再一直更新max值。举个例子：
-1 1 3 5 7    -4    -2   -9   -8 6            arr值
0  1 4 9 16  12  10   1    0   6           temp值
0  1 4 9 16  16  16   16  16 16        max值

## 最长公共子序列(动态规划)：
### 递归结构
![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/%E7%85%A7%E7%89%87%202019%E5%B9%B410%E6%9C%8822%E6%97%A5%20193305.jpg)
解释：第二个：如果新增的最后一项都一样，那么长度当然加一啦。第三个：如果不一样，当然取之前最长的那个咯。
### 复杂度
1. 计算最优解：因为有m*n个子问题，所以算法时间复杂度为：mn
2. 构造最长公共子序列：时间复杂度：m+n
3. 空间复杂度：若要记录整个序列，则需要mn，若不需要，则只要min{m，n}

## 背包问题(贪心)：

## 0-1背包问题(动态规划，回溯法，分治限界法) 
### 最优子结构性质怎么证明？
### 动态规划的递归函数：
![](%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%80%83%E7%82%B9/%E7%85%A7%E7%89%87%202019%E5%B9%B410%E6%9C%8822%E6%97%A5%20195759.jpg)
意思是：我应该保持好呢，还是去掉以前选的一些部分，再加上现在的好。
### 回溯法：
可以用子集树或者排序树来解决！计算上界要n，又有2^n个孩子，所以：n*(2^n)。
基本的解空间树思想：
原最优值为0，经过空间树的不断深入，若深入到某节点而不能再深入时（背包满了）那么就使用限界函数，在其右孩子节点寻找能塞满的最大值！直到拟寻找的最大值小于最优值为止（因为本来的最优值为0啊，所以第一次肯定一直往下），好了，第一个最优值找到后，就这样进行第二次，如果拟最优值小于目前的最优值，那么就放弃此节点，直接回溯。
### 分支限界法：
* 用最大堆实现优先队列


## 回溯法:子集树/排列树 标准伪代码;（上面有）
## 剪枝策略(约束，限界)
这个得好好说一下
### 前言：
* 剪枝：剪枝的意思是在这个搜索树中，我们可以在进入某一个节点之前大致估计一下可能的最好结果，如果最好结果没有当前最好结果好，我们可以不进入这个节点，同时将该节点的子树减掉。
* 活节点：指自身已生成但其孩子结点没有全部生成的结点；扩展节点：是指正在产生孩子结点的结点。
* 死节点：指由根结点到该结点构成的部分解不满足约束条件，或者其子结点已经搜索完毕
### 概念：
> **回溯法**搜索解空间时，通常采用两种策略避免无效搜索，提高回溯的搜索效率:（注意，剪枝函数  
1. 用**约束函数**在**扩展结点**处剪除**不满足约束的子树**，而选取满足条件的一个解（能装进去）
2. 用**限界函数**剪去**得不到问题解或最优解的子树**。（装不进去）
> 而**分支限界法**：采用一个**限界函数**，计算**限界函数值**，选择一个最有利的子结点作为**扩展结点**，使搜索朝着解空间树上有最优解的分枝推进，以便尽快地找出一个最优解；  


## 分支限界法:子集树/排列树，队列式/优先队列式伪代码思想 
* **优先队列式分枝限界的主要特点**是将活结点表组组成一个优先队列，并选取优先级最高的活结点成为当前扩展结点。步骤如下：
1. 计算起始结点（根结点）的优先级并加入优先队列（与特定问题相关的信息的函数值决定优先级）。
2. 从优先队列中取出优先级最高的结点作为当前扩展结点，使搜索朝着解空间树上可能有最优解的分枝推进，以便尽快地找出一个最优解。
3. 对当前扩展结点，先从左到右地产生它的所有孩子结点，然后用约束条件检查，对所有满足约束条件的孩子结点计算优先级并加入优先队列。
4. 重复步骤②和③，直到找到一个解或优先队列为空为止
* 而队列式就没什么好说的了，fifo嘛。
### 又是关于排列树和子集树的解释了
在子集树中，t含义是当前函数在解空间树搜索中相应的层数。 
现在我们根据这两个模板分别举两个例子。 
首先是子集树相关的定向子集求和问题。 
描述： 给一个集合，求出和为某一固定数的子集 
设计思想：利用回溯法，树的每一个节点包括1当前和2层数3剩余所有值之和。关键在于剪枝，若加上下一层的数的和小于所要求的和，则进入左子树，否则一定不可能，左子树便不生成。若减掉当前层数的再加上剩余所有数后的值依然小于所要求的和，那么右子树不生成，否则生成右子树，最后当某一层和等于所要求的和时成立并输出（中间用x[]数组来记录是否选中此数，0为未选中，1为选中）。 
## 最短路径:Dijkstra算法/ Belman-Ford算法/Floyd-Warshal算法
狄杰斯特拉算法：





